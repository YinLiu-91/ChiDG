!----------------------------------------------------------------------------------------
!!
!!  High-Level API for ChiDG HDF File Format
!!
!!  Procedures:
!!  -----------
!!
!!  read_grids_hdf
!!  write_grids_hdf
!!
!!  read_boundaryconditions_hdf
!!      read_patches_hdf
!!      read_bc_state_groups_hdf
!!
!!  write_boundaryconditions_hdf
!!      write_patches_hdf
!!      write_bc_state_groups_hdf
!!
!!  read_fields_hdf
!!      read_domain_field_hdf
!!
!!  read_auxiliary_field_hdf
!!
!!  write_fields_hdf
!!      write_domain_field_hdf
!!
!!  read_equations_hdf
!!  write_equations_hdf
!!
!!  read_prescribedmeshmotion_hdf
!!      read_pmm_groups_hdf
!!      read_pmm_domain_data_hdf
!!
!!  write_prescribedmeshmotion_hdf
!!      write_pmm_groups_hdf
!!      write_pmm_domain_data_hdf
!!
!!  read_global_connectivity_hdf
!!  TODO: write_global_connectivity_hdf
!!
!!  
!!  copy_configuration_hdf
!!
!!
!!  TODO:
!!  -----------
!!      - Relocate solution_order to a particular variable, instead of the domain.
!!        This is in case a variable is writted from another analysis like a wall
!!        distance calculation, but then a Navier Stokes solution is started.
!!      
!!
!****************************************************************************************
module mod_hdfio
#include <messenger.h>
    use mod_kinds,                  only: rk,ik,rdouble
    use mod_constants,              only: ZERO, NFACES, TWO_DIM, THREE_DIM, NO_PROC, NO_ID
    use mod_bc,                     only: create_bc
    use mod_chidg_mpi,              only: IRANK, NRANK, ChiDG_COMM

    use type_svector,               only: svector_t
    use mod_string,                 only: string_t
    use type_chidg_data,            only: chidg_data_t
    use type_meshdata,              only: meshdata_t
    use type_element_info,          only: element_info_t, element_info
    use type_domain_patch_data,     only: domain_patch_data_t
    use type_bc_state_group,        only: bc_state_group_t
    use type_bc_state,              only: bc_state_t
    use type_domain_connectivity,   only: domain_connectivity_t
    use type_partition,             only: partition_t

    use iso_c_binding,              only: c_ptr
    use mod_hdf_utilities
    use hdf5
    use h5lt
    use mpi_f08

    use type_mesh_motion,                only: mesh_motion_t
    use type_mesh_motion_group,          only: mesh_motion_group_t
    use type_mesh_motion_group_wrapper,  only: mesh_motion_group_wrapper_t
    use type_mesh_motion_domain_data,    only: mesh_motion_domain_data_t
    implicit none



contains


   
    !>  Read HDF5 grid
    !!
    !!  Opens an hdf5 file, finds how many grid domains exist, allocates that number of
    !!  domains for initialization, and calls the geometry initialization routine, passing the
    !!  points read from the hdf5 file for initialization.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[in]      filename    Character string of the file to be read
    !!  @param[inout]   domains     Allocatable array of domains. Allocated in this routine.
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_grids_hdf(filename, partition, meshdata)
        character(*),                   intent(in)      :: filename
        type(partition_t),              intent(in)      :: partition
        type(meshdata_t), allocatable,  intent(inout)   :: meshdata(:)

        integer(HID_T)   :: fid, gid, domain_id

        logical                                 :: contains_grid
        character(:),           allocatable     :: user_msg, domain_name
        integer                                 :: ierr, nterms_1d, mapping, iconn, &
                                                   nconn, nelements, nnodes
        ! Open file
        fid = open_file_hdf(filename)


        ! Check contains grid
        contains_grid = get_contains_grid_hdf(fid)
        user_msg = "We didn't find a grid to read in the file that was specified. &
                    The file could be a bare ChiDG file or maybe was generated by &
                    an incompatible version of the ChiDG library."
        if (.not. contains_grid) call chidg_signal(FATAL,user_msg)


        ! Allocate a meshdata structure for each domain connectivity in the partition
        nconn = size(partition%connectivities)
        allocate(meshdata(nconn), stat=ierr)
        if (ierr /= 0) call AllocationError


        ! Loop through groups and read domains
        do iconn = 1,nconn

            ! Open domain. Get name, get hdf identifier
            domain_name = partition%connectivities(iconn)%get_domain_name()
            domain_id = open_domain_hdf(fid,trim(domain_name))

            ! Get number of elements in the gobal domain
            meshdata(iconn)%nelements_g = get_domain_nelements_hdf(domain_id)


            ! Get number of terms in coordinate expansion
            mapping = get_domain_coordinate_order_hdf(domain_id)
            nterms_1d = (mapping + 1)


            ! Get domain name/coordinates
            meshdata(iconn)%name         = domain_name
            meshdata(iconn)%nodes        = get_domain_coordinates_hdf(domain_id)
            meshdata(iconn)%dnodes       = get_domain_coordinate_displacements_hdf(domain_id)
            meshdata(iconn)%vnodes       = get_domain_coordinate_velocities_hdf(domain_id)
            meshdata(iconn)%coord_system = get_domain_coordinate_system_hdf(domain_id)


            ! Store connectivity
            nelements = partition%connectivities(iconn)%get_nelements()
            nnodes    = partition%connectivities(iconn)%get_nnodes()
            call meshdata(iconn)%connectivity%init(domain_name,nelements,nnodes)
            meshdata(iconn)%connectivity%data = partition%connectivities(iconn)%data


            ! Read equation set attribute
            meshdata(iconn)%eqnset = get_domain_equation_set_hdf(domain_id)


            ! Close the Domain group
            call close_domain_hdf(domain_id)

        end do  ! iconn


        !  Close file and Fortran interface
        call close_file_hdf(fid)

    end subroutine read_grids_hdf
    !****************************************************************************************
  
  






    !>  Write grid to HDF file.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   3/21/2017
    !!
    !!  @param[inout]   data        chidg_data_t containing solution to be written
    !!  @param[in]      filename    Character string of the file to be written to
    !!
    !----------------------------------------------------------------------------------------
    subroutine write_grids_hdf(data,file_name)
        type(chidg_data_t), intent(in)              :: data
        character(*),       intent(in)              :: file_name


        character(:),   allocatable     :: field_name, domain_name
        integer(HID_T)                  :: fid, domain_id
        integer(HSIZE_T)                :: adim
        integer(ik)                     :: idom, time, &
                                           field_index, iproc, nelements_g, ielem, eqn_ID
        integer                         :: ierr, order_s
        logical                         :: file_exists
        integer(ik)                     :: itime, connectivity_size, order_c
        integer(ik),    allocatable     :: elements(:,:)



        ! Write solution for each domain
        fid = open_file_hdf(file_name)
        do idom = 1,data%mesh%ndomains()

            domain_name = data%mesh%domain(idom)%name
            domain_id   = open_domain_hdf(fid,trim(domain_name))
            
            ! Write domain attributes: solution order, equation set
            order_c = 0
            do while ( order_c*order_c*order_c /= data%mesh%domain(idom)%elems(1)%nterms_c )
               order_c = order_c + 1 
            end do
            order_c = order_c - 1 ! to be consistent with the definition of 'Order of the polynomial'


            ! Write nodes, displacements, velocities, coordinate system
            call set_domain_coordinate_order_hdf(        domain_id,order_c )
            call set_domain_coordinates_hdf(             domain_id,data%mesh%domain(idom)%nodes            )
            call set_domain_coordinate_displacements_hdf(domain_id,data%mesh%domain(idom)%dnodes           )
            call set_domain_coordinate_velocities_hdf(   domain_id,data%mesh%domain(idom)%vnodes           )
            call set_domain_coordinate_system_hdf(       domain_id,data%mesh%domain(idom)%coordinate_system)


            ! Assemble element connectivities
            connectivity_size = size(data%mesh%domain(idom)%elems(1)%connectivity)
            
            if (allocated(elements)) deallocate(elements)
            allocate(elements(data%mesh%domain(idom)%nelem, connectivity_size+3), stat=ierr)
            if (ierr /= 0) call AllocationError

            do ielem = 1,data%mesh%domain(idom)%nelem
                elements(ielem,1)  = data%mesh%domain(idom)%elems(ielem)%idomain_g
                elements(ielem,2)  = data%mesh%domain(idom)%elems(ielem)%ielement_g
                elements(ielem,3)  = data%mesh%domain(idom)%elems(ielem)%element_type
                elements(ielem,4:) = data%mesh%domain(idom)%elems(ielem)%connectivity
            end do


            ! Set elements
            nelements_g = data%mesh%domain(idom)%get_nelements_global()
            call set_domain_connectivity_partition_hdf(domain_id,nelements_g,elements)


            ! Write equation set attribute
            eqn_ID = data%mesh%domain(idom)%elems(1)%eqn_ID !assume each element has the same eqn_ID
            !call set_domain_equation_set_hdf(domain_id,trim(data%eqnset(eqn_ID)%name))
            call set_domain_equation_set_hdf(domain_id,trim(data%eqnset(eqn_ID)%get_name()))


            call close_domain_hdf(domain_id)

        end do ! idom

        call set_contains_grid_hdf(fid,"True")
        call close_file_hdf(fid)

    end subroutine write_grids_hdf
    !*****************************************************************************************

  
   







    !>  Read solution modes from HDF file.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[in]      filename    Character string of the file to be read from
    !!  @param[inout]   data        chidg_data_t that will accept the solution modes
    !!
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_fields_hdf(filename,data)
        character(*),       intent(in)              :: filename
        type(chidg_data_t), intent(inout)           :: data

        integer(HID_T)                  :: fid, domain_id
        integer                         :: ierr

        real(rk),           allocatable :: times(:)
        integer(ik)                     :: idom, ndomains, ifield, nfields, itime, ntime, eqn_ID, iread
        character(:),       allocatable :: field_name, user_msg, domain_name
        logical                         :: file_exists, contains_solution


        ! Each process read ntime in serial
        ndomains = data%mesh%ndomains()
        do iread = 0,NRANK-1
            if ( iread == IRANK ) then

                ! Open file
                fid = open_file_hdf(filename)

                ! Check file contains solution
                contains_solution = get_contains_solution_hdf(fid)
                user_msg = "We didn't find a solution to read in the file that was specified. &
                            You could set solutionfile_in = 'none' to initialize a solution &
                            to default values instead."
                if (.not. contains_solution) call chidg_signal(FATAL,user_msg)

                ! Read solution for each time step
                times = get_times_hdf(fid)
                ntime = size(times)

                ! Close file
                call close_file_hdf(fid)

            end if
            call MPI_Barrier(ChiDG_COMM,ierr)
        end do ! iread


        ! Initialize q_in. This is collective so we don't want it inside a serial read loop
        call data%sdata%q_in%init(data%mesh,ntime)
        call data%sdata%q_in%set_ntime(ntime)


        ! Each process reads solution in serial 
        do iread = 0,NRANK-1
            if ( iread == IRANK ) then

                ! Open file
                fid = open_file_hdf(filename)
                do itime = 1,ntime
                    do idom = 1,ndomains

                        ! Get domain name and number of primary fields
                        domain_name = data%mesh%domain(idom)%name

                        ! For each primary field in the domain, get the field name and read from file.
                        domain_id = open_domain_hdf(fid,domain_name)

                        eqn_ID = data%mesh%domain(idom)%elems(1)%eqn_ID !assume each element has the same eqn_ID
                        do ifield = 1,data%eqnset(eqn_ID)%prop%nprimary_fields()
                            field_name = trim(data%eqnset(eqn_ID)%prop%get_primary_field_name(ifield))
                            call read_domain_field_hdf(data,domain_id,field_name,itime,'Primary')
                        end do ! ifield

                        call close_domain_hdf(domain_id)

                    end do ! idom
                end do ! itime

                ! Close file
                call close_file_hdf(fid)

            end if
            call MPI_Barrier(ChiDG_COMM,ierr)
        end do ! iread


        ! Assemble
        call data%sdata%q_in%assemble()


    end subroutine read_fields_hdf
    !****************************************************************************************





    !>  Read solution modes from HDF file.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[in]      filename    Character string of the file to be read from
    !!  @param[inout]   data        chidg_data_t that will accept the solution modes
    !!
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_auxiliary_field_hdf(filename,data,field,store_as)
        character(*),       intent(in)      :: filename
        type(chidg_data_t), intent(inout)   :: data
        character(*),       intent(in)      :: field
        character(*),       intent(in)      :: store_as

        integer(HID_T)                  :: fid, domain_id
        integer                         :: ierr

        real(rk),           allocatable :: times(:)
        integer(ik)                     :: idom, ndomains, ifield, nfields, itime, ntime, eqn_ID, iread, field_ID, aux_ID
        character(:),       allocatable :: field_name, user_msg, domain_name
        logical                         :: file_exists, contains_solution


        ! Each process read ntime in serial
        ndomains = data%mesh%ndomains()
        do iread = 0,NRANK-1
            if ( iread == IRANK ) then

                ! Open file
                fid = open_file_hdf(filename)

                ! Check file contains solution
                contains_solution = get_contains_solution_hdf(fid)
                user_msg = "We didn't find a solution to read in the file that was specified. &
                            You could set solutionfile_in = 'none' to initialize a solution &
                            to default values instead."
                if (.not. contains_solution) call chidg_signal(FATAL,user_msg)

                ! Read solution for each time step
                times = get_times_hdf(fid)
                ntime = size(times)

                ! Close file
                call close_file_hdf(fid)

            end if
            call MPI_Barrier(ChiDG_COMM,ierr)
        end do ! iread

        ! Find auxiliary field in existing storage
        aux_ID = data%sdata%get_auxiliary_field_index(trim(store_as))
        if (aux_ID == NO_ID) aux_ID = data%sdata%add_auxiliary_field(trim(store_as))

        ! Initialize auxiliary_field vector. This is collective so we don't want it inside a serial read loop
        call data%sdata%auxiliary_field(aux_ID)%init(data%mesh,ntime)
        call data%sdata%auxiliary_field(aux_ID)%set_ntime(ntime)


        ! Each process reads solution in serial 
        do iread = 0,NRANK-1
            if ( iread == IRANK ) then

                ! Open file
                fid = open_file_hdf(filename)
                do itime = 1,ntime
                    do idom = 1,ndomains

                        ! Get domain name and number of primary fields
                        domain_name = data%mesh%domain(idom)%name

                        ! For each primary field in the domain, get the field name and read from file.
                        domain_id = open_domain_hdf(fid,domain_name)
                        eqn_ID = data%mesh%domain(idom)%elems(1)%eqn_ID !assume each element has the same eqn_ID

                        ! Read field
                        call read_domain_field_hdf(data,domain_id,field,itime,'Auxiliary',store_as)

                        ! Close domain
                        call close_domain_hdf(domain_id)

                    end do ! idom
                end do ! itime

                ! Close file
                call close_file_hdf(fid)

            end if
            call MPI_Barrier(ChiDG_COMM,ierr)
        end do ! iread


        ! Assemble
        call data%sdata%auxiliary_field(aux_ID)%assemble()


    end subroutine read_auxiliary_field_hdf
    !****************************************************************************************











    !> Write solution modes to HDF file.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[in]      filename    Character string of the file to be written to
    !!  @param[inout]   data        chidg_data_t containing solution to be written
    !!
    !!
    !!  @autor Matteo Ugolotti
    !!  @date   2/22/2017
    !!
    !----------------------------------------------------------------------------------------
    subroutine write_fields_hdf(data,file_name,field)
        type(chidg_data_t), intent(inout)           :: data
        character(*),       intent(in)              :: file_name
        character(*),       intent(in), optional    :: field


        character(:),   allocatable     :: field_name, domain_name
        integer(HID_T)                  :: fid, domain_id
        integer(HSIZE_T)                :: adim, nfreq, ntime
        integer(ik)                     :: idom, ifield, nfields, iwrite, &
                                           time, field_index, iproc, eqn_ID
        integer                         :: ierr, order_s
        logical                         :: file_exists
        integer(ik)                     :: itime


        ! Check for file existence
        file_exists = check_file_exists_hdf(file_name)

        ! Make sure q is assembled so it doesn't trigger a collective operation
        ! inside of a sequential operation
        call data%sdata%q%assemble()


        ! Create new file if necessary
        !   Barrier makes sure everyone has called file_exists before
        !   one potentially gets created by another processor
        call MPI_Barrier(ChiDG_COMM,ierr)
        if (.not. file_exists) then


                ! Create a new file
                if (IRANK == GLOBAL_MASTER) then
                    call initialize_file_hdf(file_name)
                end if
                call MPI_Barrier(ChiDG_COMM,ierr)


                ! Initialize the file structure.
                do iproc = 0,NRANK-1
                    if (iproc == IRANK) then
                        fid = open_file_hdf(file_name)
                        call initialize_file_structure_hdf(fid,data%mesh)
                        call close_file_hdf(fid)
                    end if
                    call MPI_Barrier(ChiDG_COMM,ierr)
                end do

        end if
        call MPI_Barrier(ChiDG_COMM,ierr)



        ! Each process, write its own portion of the solution
        do iwrite = 0,NRANK-1
            if ( iwrite == IRANK ) then

                fid = open_file_hdf(file_name)


                ! Write solution for each domain
                do idom = 1,data%mesh%ndomains()

                    domain_name = data%mesh%domain(idom)%name
                    eqn_ID      = data%mesh%domain(idom)%elems(1)%eqn_ID !assume each element has same eqn_ID
                    domain_id   = open_domain_hdf(fid,trim(domain_name))
                    
                    ! Write domain attributes: solution order, equation set
                    adim = 1
                    order_s = 0
                    do while ( order_s*order_s*order_s /= data%mesh%domain(idom)%nterms_s )
                       order_s = order_s + 1 
                    end do
                    order_s = order_s - 1 ! to be consistent with he definition of 'Order of the polynomial'


                    ! Set some data about the block: solution order + equation set
                    call set_domain_field_order_hdf(domain_id,order_s)
                    

                    ! Loop through time levels
                    do itime = 1,data%ntime()

                        ! If specified, only write specified field.
                        if (present(field)) then
                            field_index = data%eqnset(eqn_ID)%prop%get_primary_field_index(trim(field))

                            if (field_index /= 0) then
                                call write_domain_field_hdf(domain_id,data,field,itime)
                            end if

                        else
                        ! Else, write each field in the file.
                            ! For each field: get the name, write to file
                            nfields = data%eqnset(eqn_ID)%prop%nprimary_fields()
                            do ifield = 1,nfields
                                field_name = trim(data%eqnset(eqn_ID)%prop%get_primary_field_name(ifield))
                                call write_domain_field_hdf(domain_id,data,field_name,itime)
                            end do ! ifield
                        end if

                    end do ! itime

                    call close_domain_hdf(domain_id)

                end do ! idom


                call set_contains_solution_hdf(fid,"True")
                call close_file_hdf(fid)

            end if
            call MPI_Barrier(ChiDG_COMM,ierr)
        end do

    end subroutine write_fields_hdf
    !*****************************************************************************************

   
   
   
   
   
  
  
   
    !>  Read HDF5 variable
    !!
    !!  Opens a given ChiDG-formatted HDF file. Loads the equation set and solution order
    !!  and calls solution initialization procedure for each domain. Searches for the given
    !!  variable and time instance. If it finds it, load to a
    !!
    !!  Note: Convention is that all floating-point data is double precision format.
    !!        Conversion to working-precision should happen after reading the data from 
    !!        the HDF file.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[inout]   data        ChiDG data containing domains. Already allocated.
    !!  @param[in]      domain_id   HDF5 Domain identifier.
    !!  @param[in]      field_name  Character string of the field to be read.
    !!  @param[in]      itime       Integer of the time instance for the current variable 
    !!                              to be read.
    !!
    !!  @author Mayank Sharma + Matteo Ugolotti
    !!  @date   11/5/2016
    !!
    !!
    !---------------------------------------------------------------------------------------
    subroutine read_domain_field_hdf(data,domain_id,field_name,itime,field_type,store_as)
        type(chidg_data_t),         intent(inout)           :: data
        integer(HID_T),             intent(in)              :: domain_id
        character(*),               intent(in)              :: field_name
        integer(ik),                intent(in)              :: itime
        character(*),               intent(in)              :: field_type
        character(*),               intent(in), optional    :: store_as


        integer(HID_T)          :: gid, sid, vid, memspace
        integer(HSIZE_T)        :: start(3), count(3), dimsm(3)
        integer, dimension(1)   :: ibuf


        character(:),   allocatable         :: user_msg, domain_name
        character(100)                      :: cbuf, var_gqp

        real(rdouble),  allocatable, target :: var(:,:,:)
        real(rdouble),  allocatable         :: bufferterms(:)
        type(c_ptr)                         :: cp_var
        type(element_info_t)                :: elem_info

        integer(ik)                         :: ielem_g, aux_ID, eqn_ID
        integer                             :: type, ierr, nterms_1d, nterms_s, order,  &
                                               ifield, ielem, nterms_ielem, idom, ndims
        logical                             :: ElementsEqual, variables_exists


        ! Check valid field_type input
        if ( (trim(field_type) /= 'Primary') .and. &
             (trim(field_type) /= 'Auxiliary') ) then
             user_msg = "read_field_domain_hdf: An invalid field type was passed to the routine. &
                         valid field types are 'Primary' and 'Auxiliary'."
             call chidg_signal_one(FATAL,user_msg,trim(field_type))
        end if


        ! Check if 'Fields' group exists
        call h5lexists_f(domain_id, "Fields", variables_exists, ierr)
        if (.not. variables_exists) call chidg_signal(FATAL,"read_field_domain_hdf: Fields group does not exist")


        ! Open the Domain/Fields group
        call h5gopen_f(domain_id, "Fields", gid, ierr, H5P_DEFAULT_F)
        if (ierr /= 0) call chidg_signal(FATAL,"read_field_domain_hdf: h5gopen_f -- Fields group did not open properly")


        ! Get number of terms in solution expansion
        order = get_domain_field_order_hdf(domain_id)
        nterms_1d = (order + 1) ! To be consistent with the definition of (Order = 'Order of the polynomial')


        domain_name = get_domain_name_hdf(domain_id)
        idom     = data%get_domain_index(domain_name)
        nterms_s = nterms_1d*nterms_1d*nterms_1d

        
        ! Open the Variable dataset
        call h5dopen_f(gid, trim(field_name), vid, ierr, H5P_DEFAULT_F)
        if (ierr /= 0) call chidg_signal(FATAL,"read_field_domain_hdf: variable does not exist or was not opened correctly")


        ! Get the dataspace id and dimensions
        call h5dget_space_f(vid, sid, ierr)


        ! Find correct auxiliary vector to read in to
        if (field_type == 'Auxiliary') then 
            if (present(store_as)) then
                aux_ID = data%sdata%get_auxiliary_field_index(trim(store_as))
                if (aux_ID == NO_ID) aux_ID = data%sdata%add_auxiliary_field(trim(store_as))
            else
                aux_ID = data%sdata%get_auxiliary_field_index(trim(field_name))
                if (aux_ID == NO_ID) aux_ID = data%sdata%add_auxiliary_field(trim(field_name))
            end if
        end if



        ! Allocate storage for incoming element modes, create a memory dataspace (memspace)
        allocate(var(nterms_s,1,1))
        cp_var = c_loc(var(1,1,1))

        ndims    = 3
        dimsm(1) = size(var,1)
        dimsm(2) = size(var,2)
        dimsm(3) = size(var,3)
        call h5screate_simple_f(ndims,dimsm,memspace,ierr)



        !  Loop through elements and set 'variable' values
        do ielem = 1,data%mesh%domain(idom)%nelem
            eqn_ID = data%mesh%domain(idom)%elems(ielem)%eqn_ID

            elem_info = element_info(idomain_g       = data%mesh%domain(idom)%elems(ielem)%idomain_g,        &
                                     idomain_l       = data%mesh%domain(idom)%elems(ielem)%idomain_l,        &
                                     ielement_g      = data%mesh%domain(idom)%elems(ielem)%ielement_g,       &
                                     ielement_l      = data%mesh%domain(idom)%elems(ielem)%ielement_l,       &
                                     iproc           = data%mesh%domain(idom)%elems(ielem)%iproc,            &
                                     pelem_ID        = NO_ID,                                                &
                                     eqn_ID          = data%mesh%domain(idom)%elems(ielem)%eqn_ID,           &
                                     nfields         = data%mesh%domain(idom)%elems(ielem)%nfields,          &
                                     ntime           = data%mesh%domain(idom)%elems(ielem)%ntime,            &
                                     nterms_s        = data%mesh%domain(idom)%elems(ielem)%nterms_s,         &
                                     nterms_c        = data%mesh%domain(idom)%elems(ielem)%nterms_c,         &
                                     dof_start       = data%mesh%domain(idom)%elems(ielem)%dof_start,        &
                                     dof_local_start = data%mesh%domain(idom)%elems(ielem)%dof_local_start,  &
                                     recv_comm       = data%mesh%domain(idom)%elems(ielem)%recv_comm,        &
                                     recv_domain     = data%mesh%domain(idom)%elems(ielem)%recv_domain,      &
                                     recv_element    = data%mesh%domain(idom)%elems(ielem)%recv_element,     &
                                     recv_dof        = data%mesh%domain(idom)%elems(ielem)%recv_dof)


            ! Get number of terms initialized for the current element
            nterms_ielem = data%mesh%domain(idom)%elems(ielem)%nterms_s


            ! get domain-global element index
            ielem_g = data%mesh%domain(idom)%elems(ielem)%ielement_g
            start = [1-1,ielem_g-1,itime-1] ! 0-based 
            count = [nterms_s, 1, 1]
            

            ! Allocate bufferterm storage that will be used to set variable data
            if (allocated(bufferterms)) deallocate(bufferterms)
            allocate(bufferterms(nterms_ielem), stat=ierr)
            if (ierr /= 0) call AllocationError



            ! Select subset of dataspace - sid, read selected modes into cp_var 
            call h5sselect_hyperslab_f(sid, H5S_SELECT_SET_F, start, count, ierr)
            if (ierr /= 0) call chidg_signal(FATAL,"read_domain_field_hdf: h5sselect_hyperslab_f.")
            call h5dread_f(vid, H5T_NATIVE_DOUBLE, cp_var, ierr, memspace, sid)
            if (ierr /= 0) call chidg_signal(FATAL,"read_domain_field_hdf: h5d_read_f_f.")


            ! Check for reading lower, higher, or same-order solution
            bufferterms = ZERO
            if ( nterms_s < nterms_ielem ) then
                ! Reading a lower-order solution
                bufferterms(1:nterms_s) = var(1:nterms_s, 1, 1)
            else if ( nterms_s > nterms_ielem ) then
                ! Reading a higher-order solution
                bufferterms(1:nterms_ielem) = var(1:nterms_ielem, 1, 1)
            else
                ! Reading a solution of same order
                bufferterms(1:nterms_ielem) = var(1:nterms_ielem, 1, 1)
            end if


            ! Store modes in ChiDG Vector
            if (field_type == 'Primary') then
                ifield = data%eqnset(eqn_ID)%prop%get_primary_field_index(trim(field_name))
                call data%sdata%q_in%set_field(real(bufferterms,rk),elem_info,ifield,itime)
            else if (field_type == 'Auxiliary') then
                ! Implicitly assuming that an auxiliary field is stored as the first field in a full-sized chidg_vector
                ifield = 1
                call data%sdata%auxiliary_field(aux_ID)%set_field(real(bufferterms,rk),elem_info,ifield,itime) 
            end if


        end do


        ! Close variable dataset, domain/variable group.
        call h5sclose_f(memspace,ierr)  ! Close memory space
        call h5dclose_f(vid,ierr)       ! Close field dataset
        call h5sclose_f(sid,ierr)       ! Close field dataspaces
        call h5gclose_f(gid,ierr)       ! Close Domain/Field group


    end subroutine read_domain_field_hdf
    !*************************************************************************************
   
   
   
   
   
   
  






    !>  Write HDF5 field to a Domain.
    !!
    !!  Loads the equation set and solution order and calls solution
    !!  initialization procedure for each domain. Searches for the given field and time
    !!  instance.
    !!
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[in]  data        chidg_data_t instance containing grid and solution.
    !!  @param[in]  domain_id   HDF5 file identifier.
    !!  @param[in]  field_name  Character string of the field name to be read.
    !!  @param[in]  itime       Integer of the time instance for the current field
    !!                          to be read.
    !!
    !!  @author Mayank Sharma + Matteo Ugolotti
    !!  @date   11/5/2016
    !!
    !!
    !!  @author Matteo Ugolotti
    !!  @date   02/20/2017
    !!
    !!  Expanded the dataspace to include all the time levels
    !!
    !----------------------------------------------------------------------------------------
    subroutine write_domain_field_hdf(domain_id,data,field_name,itime,attribute_name,attribute_value)
        integer(HID_T),     intent(in)              :: domain_id
        type(chidg_data_t), intent(inout)           :: data
        character(*),       intent(in)              :: field_name
        integer(ik),        intent(in)              :: itime
        character(*),       intent(in), optional    :: attribute_name
        real(rk),           intent(in), optional    :: attribute_value


        type(H5O_INFO_T) :: info
        integer(HID_T)   :: gid, sid, did, crp_list, memspace, filespace
        integer(HSIZE_T) :: edims(2), maxdims(3), dims(3), dimsm(3), dimsc(3), &
                            start(3), count(3)

        type(element_info_t)    :: elem_info

        integer                             :: ndims, ibuf(1)
        character(100)                      :: cbuf, var_grp, ctime
        character(:),   allocatable         :: domain_name
        real(rdouble),  allocatable, target :: var(:,:,:)
        type(c_ptr)                         :: cp_var

        logical     :: DataExists, ElementsEqual, exists
        integer(ik) :: type, ierr, ndomains,    &
                       order, ivar, ielem, idom, nelem_g, &
                       ielement_g, nterms_s, ntime, eqn_ID


        !
        ! Open the Domain/Fields group
        !
        call h5lexists_f(domain_id, "Fields", exists, ierr)
        if (exists) then
            call h5gopen_f(domain_id, "Fields", gid, ierr, H5P_DEFAULT_F)
        else
            call h5gcreate_f(domain_id, "Fields", gid, ierr)
        end if
        if (ierr /= 0) call chidg_signal(FATAL,"write_field_domain_hdf: Domain/Fields group did not open properly.")



        !
        ! Set dimensions of dataspace to write
        !
        domain_name = get_domain_name_hdf(domain_id)
        idom        = data%get_domain_index(domain_name)
        nelem_g     = data%mesh%domain(idom)%get_nelements_global()
        nterms_s    = data%mesh%domain(idom)%nterms_s
        ndims       = 3
        ntime       = data%ntime()

        !
        ! Set the dimensions of the dataspace to write in
        !
        dims(1:3)    = [nterms_s, nelem_g, ntime]
        maxdims(1:3) = H5S_UNLIMITED_F


        !
        ! Modify dataset creation properties, i.e. enable chunking in order to append
        ! dataspace, if needed.
        !
        dimsc = [1, nelem_g, 1]  ! Chunk size

        call h5pcreate_f(H5P_DATASET_CREATE_F, crp_list, ierr)
        if (ierr /= 0) call chidg_signal(FATAL, "write_field_domain_hdf: h5pcreate_f error enabling chunking.")

        call h5pset_chunk_f(crp_list, ndims, dimsc, ierr)
        if (ierr /= 0) call chidg_signal(FATAL, "write_field_domain_hdf: h5pset_chunk_f error setting chunk properties.")



        !
        ! Reset dataspace size if necessary
        !
        call h5lexists_f(gid, trim(field_name), exists, ierr)
        if (exists) then
            ! Open the existing dataset
            call h5dopen_f(gid, trim(field_name), did, ierr, H5P_DEFAULT_F)
            if (ierr /= 0) call chidg_signal(FATAL,"write_field_domain_hdf: field does not exist or was not opened correctly.")


            ! Extend dataset if necessary
            call h5dset_extent_f(did, dims, ierr)
            if (ierr /= 0) call chidg_signal(FATAL, "write_field_domain_hdf: h5dset_extent_f.")


            ! Update existing dataspace ID since it may have been expanded
            call h5dget_space_f(did, sid, ierr)
            if (ierr /= 0) call chidg_signal(FATAL, "write_field_domain_hdf: h5dget_space_f.")

        else
            ! Create a new dataspace
            call h5screate_simple_f(ndims,dims,sid,ierr,maxdims)
            if (ierr /= 0) call chidg_signal(FATAL,"write_field_domain_hdf: h5screate_simple_f.")


            ! Create a new dataset
            call h5dcreate_f(gid, trim(field_name), H5T_NATIVE_DOUBLE, sid, did, ierr, crp_list)
            if (ierr /= 0) call chidg_signal(FATAL,"write_field_domain_hdf: h5dcreate_f.")
        end if



        !
        ! Assemble field buffer matrix that gets written to file
        !
        allocate(var(nterms_s,1,1))



        do ielem = 1,data%mesh%domain(idom)%nelem

            elem_info = element_info(idomain_g       = data%mesh%domain(idom)%elems(ielem)%idomain_g,        &
                                     idomain_l       = data%mesh%domain(idom)%elems(ielem)%idomain_l,        &
                                     ielement_g      = data%mesh%domain(idom)%elems(ielem)%ielement_g,       &
                                     ielement_l      = data%mesh%domain(idom)%elems(ielem)%ielement_l,       &
                                     iproc           = data%mesh%domain(idom)%elems(ielem)%iproc,            &
                                     pelem_ID        = NO_ID,                                                &
                                     eqn_ID          = data%mesh%domain(idom)%elems(ielem)%eqn_ID,           &
                                     nfields         = data%mesh%domain(idom)%elems(ielem)%nfields,          &
                                     ntime           = data%mesh%domain(idom)%elems(ielem)%ntime,            &
                                     nterms_s        = data%mesh%domain(idom)%elems(ielem)%nterms_s,         &
                                     nterms_c        = data%mesh%domain(idom)%elems(ielem)%nterms_c,         &
                                     dof_start       = data%mesh%domain(idom)%elems(ielem)%dof_start,        &
                                     dof_local_start = data%mesh%domain(idom)%elems(ielem)%dof_local_start,  &
                                     recv_comm       = data%mesh%domain(idom)%elems(ielem)%recv_comm,        &
                                     recv_domain     = data%mesh%domain(idom)%elems(ielem)%recv_domain,      &
                                     recv_element    = data%mesh%domain(idom)%elems(ielem)%recv_element,     &
                                     recv_dof        = data%mesh%domain(idom)%elems(ielem)%recv_dof)

            !
            ! Get field integer index from field character string
            !
            eqn_ID = data%mesh%domain(idom)%elems(ielem)%eqn_ID
            ivar = data%eqnset(eqn_ID)%prop%get_primary_field_index(field_name)


            !
            ! get domain-global element index
            !
            ielement_g = data%mesh%domain(idom)%elems(ielem)%ielement_g
            start = [1-1,ielement_g-1,itime-1]   ! 0-based
            count = [nterms_s, 1, 1]

            !
            ! Select subset of dataspace - sid
            !
            call h5sselect_hyperslab_f(sid, H5S_SELECT_SET_F, start, count, ierr)

            !
            ! Create a memory dataspace
            !
            dimsm(1) = size(var,1)
            dimsm(2) = size(var,2)
            dimsm(3) = size(var,3)
            call h5screate_simple_f(ndims,dimsm,memspace,ierr)


            !
            ! Write modes
            !
            !var(:,1,1) = real(data%sdata%q%dom(idom)%vecs(ielem)%getvar(ivar,itime),rdouble)
            var(:,1,1) = real(data%sdata%q%get_field(elem_info,ivar,itime),rdouble)
            cp_var = c_loc(var(1,1,1))
            call h5dwrite_f(did, H5T_NATIVE_DOUBLE, cp_var, ierr, memspace, sid)


            call h5sclose_f(memspace,ierr)


        end do




        call h5pclose_f(crp_list, ierr) ! Close dataset creation property
        call h5dclose_f(did,ierr)       ! Close Field datasets
        call h5sclose_f(sid,ierr)       ! Close Field dataspaces
        call h5gclose_f(gid,ierr)       ! Close Domain/Field group


    end subroutine write_domain_field_hdf
    !****************************************************************************************













    !>  Read boundary conditions from HDF5 file in ChiDG format and return data in bcdata_t
    !!  container. The calling procedure can then use the returned bcdata_t to initialize
    !!  boundary conditions.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   6/9/2016
    !!
    !!  @param[in]      filename    String of the HDF5 file to be read.
    !!  @param[inout]   bcdata(:)   Array of bcdata_t instances, one for each domain. 
    !!                              These will be returned with data about the boundary
    !!                              conditions that can be used for initialization.
    !!  @param[in]      partition   Partition information to only read boundary conditions 
    !!                              for the domains in the partition
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_boundaryconditions_hdf(filename, patch_data, bc_state_groups, partition)
        character(*),               intent(in)                  :: filename
        type(domain_patch_data_t),  intent(inout), allocatable  :: patch_data(:)
        type(bc_state_group_t),     intent(inout), allocatable  :: bc_state_groups(:)
        type(partition_t),          intent(in)                  :: partition

        integer(HID_T)          :: fid
        integer                 :: ierr, nconn

        fid = open_file_hdf(filename)

        ! Allocate for number of domains in the partition
        nconn = size(partition%connectivities)
        allocate(patch_data(nconn), stat=ierr)
        if (ierr /= 0) call AllocationError


        ! Read domain patches
        call read_patches_hdf(fid,patch_data,partition)


        ! Read boundary condition state groups
        call read_bc_state_groups_hdf(fid,bc_state_groups,partition)


        call close_file_hdf(fid)

    end subroutine read_boundaryconditions_hdf
    !****************************************************************************************








    !>  Read boundary conditions from HDF5 file in ChiDG format and return data in bcdata_t
    !!  container. The calling procedure can then use the returned bcdata_t to initialize
    !!  boundary conditions.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   6/9/2016
    !!
    !!  @param[in]      filename    String of the HDF5 file to be read.
    !!  @param[inout]   bcdata(:)   Array of bcdata_t instances, one for each domain. 
    !!                              These will be returned with data about the boundary
    !!                              conditions that can be used for initialization.
    !!  @param[in]      partition   Partition information to only read boundary conditions 
    !!                              for the domains in the partition
    !!
    !----------------------------------------------------------------------------------------
    subroutine write_boundaryconditions_hdf(data,file_name)
        type(chidg_data_t), intent(in)  :: data
        character(*),       intent(in)  :: file_name

        ! Read domain patches
        call write_patches_hdf(data,file_name)

        ! Read boundary condition state groups
        call write_bc_state_groups_hdf(data,file_name)

    end subroutine write_boundaryconditions_hdf
    !****************************************************************************************









    !>  Read the boundary condition patch connectivity data from file and store in
    !!  patch_data.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   8/31/2016
    !!
    !!
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_patches_hdf(fid, patch_data, partition)
        integer(HID_T),             intent(in)      :: fid
        type(domain_patch_data_t),  intent(inout)   :: patch_data(:)
        type(partition_t),          intent(in)      :: partition

        integer(ik)                 :: iconn, nconn, ipatch, npatches, ierr
        integer(ik),    allocatable :: patch(:,:)
        character(:),   allocatable :: group_name, patch_name
        integer                     :: ibc_face, nbcfaces
        character(1024)             :: domain
        character(len=10)           :: patches(NFACES)

        integer(HID_T)              :: dom_id, patch_id


        patches = ["  XI_MIN","  XI_MAX"," ETA_MIN"," ETA_MAX","ZETA_MIN","ZETA_MAX"]


        !
        !  Loop through connectivities and read boundary conditions
        !
        nconn = size(partition%connectivities)
        do iconn = 1,nconn


            !
            ! Get name of current domain, open domain group
            !
            domain = partition%connectivities(iconn)%get_domain_name()
            patch_data(iconn)%domain_name = domain
            dom_id = open_domain_hdf(fid,trim(domain))


            !
            ! Allocation bcs for current domain
            !
            npatches = get_npatches_hdf(dom_id)
            allocate(patch_data(iconn)%bc_connectivity(npatches), stat=ierr)
            if (ierr /= 0) call AllocationError


            !
            ! Loop faces and get boundary condition for each
            !
            ! TODO: should probably turn this into a loop over bcs instead of faces.
            do ipatch = 1,npatches


                ! Open face boundary condition group
                patch_id = open_patch_hdf(dom_id,patches(ipatch))
    

                ! Get bc patch connectivity for current face
                patch = get_patch_hdf(patch_id)
                nbcfaces = size(patch,1)


                ! Store boundary condition connectivity
                call patch_data(iconn)%bc_connectivity(ipatch)%init(nbcfaces)
                do ibc_face = 1,nbcfaces
                    patch_data(iconn)%bc_connectivity(ipatch)%data(ibc_face)%data = patch(ibc_face,:)
                end do

                
                ! Read Boundary State Group
                group_name = get_patch_group_hdf(patch_id)
                patch_name = patches(ipatch)
                call patch_data(iconn)%group_name%push_back(string_t(trim(group_name)))
                call patch_data(iconn)%patch_name%push_back(string_t(trim(patch_name)))


                ! Close face boundary condition group
                call close_patch_hdf(patch_id)

            end do ! ipatch


            ! Close domain group
            call close_domain_hdf(dom_id)


        end do  ! iconn



    end subroutine read_patches_hdf
    !****************************************************************************************














    !>  Read boundary condition state groups from file and return.
    !!
    !!  Reads and returns all boundary condition state groups, regardless of if they
    !!  are used on the current partition or not.
    !!
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   8/31/2016
    !!
    !---------------------------------------------------------------------------------------
    subroutine read_bc_state_groups_hdf(fid, bc_state_groups, partition)
        integer(HID_T),             intent(in)                  :: fid
        type(bc_state_group_t),     intent(inout), allocatable  :: bc_state_groups(:)
        type(partition_t),          intent(in)                  :: partition

        character(:),       allocatable     :: user_msg
        type(svector_t)                     :: bc_group_names, bc_state_names
        type(string_t)                      :: group_name, state_name
        class(bc_state_t),  allocatable     :: bc

        integer(HID_T)  :: group_id
        integer(ik)     :: igroup, ngroups, istate, ierr


        ngroups        = get_nbc_state_groups_hdf(fid)
        bc_group_names = get_bc_state_group_names_hdf(fid)


        if (allocated(bc_state_groups)) deallocate(bc_state_groups)
        allocate(bc_state_groups(ngroups), stat=ierr)
        if (ierr /= 0) call AllocationError


        !
        ! Read each group of bc_state's
        !
        do igroup = 1,ngroups

            ! Open face boundary condition group
            group_name = bc_group_names%at(igroup)
            group_id = open_bc_state_group_hdf(fid,group_name%get())

            !
            ! Get bc_group Family attribute.
            !
            bc_state_groups(igroup)%family = get_bc_state_group_family_hdf(group_id)

            !
            ! Loop through and read states + their properties
            !
            bc_state_names = get_bc_state_names_hdf(group_id)
            do istate = 1,bc_state_names%size()

                ! Get bc_state name, return bc_state from file and source-allocate
                state_name = bc_state_names%at(istate)
                if (allocated(bc)) deallocate(bc)
                allocate(bc, source = get_bc_state_hdf(group_id,state_name%get()))

                ! Save to bc_state_group_data_t
                bc_state_groups(igroup)%name = group_name%get()
                call bc_state_groups(igroup)%add_bc_state(bc)

            end do !istate

            ! Test for correct number of bc_states added to bc_state_group
            user_msg = "read_bc_state_groups_hdf: It appears the bc_state objects were not &
                        added correctly to their associated bc_state_group."
            if (bc_state_names%size() /= bc_state_groups(igroup)%nbc_states()) call chidg_signal(FATAL,user_msg)


            ! Close face boundary condition group
            call close_bc_state_group_hdf(group_id)

        end do !igroup



    end subroutine read_bc_state_groups_hdf
    !****************************************************************************************











    !>  Write the boundary condition patch connectivity data from chidg and store in file.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   06/01/2017
    !!
    !!  TODO: TEST
    !!
    !----------------------------------------------------------------------------------------
    subroutine write_patches_hdf(data,file_name)
        type(chidg_data_t), intent(in)  :: data
        character(*),       intent(in)  :: file_name

        logical                     :: file_exists, exists
        integer(ik)                 :: idom, igroup, ipatch, ierr, iface, nfaces, npts
        integer(ik),    allocatable :: faces(:,:)
        integer(HID_T)              :: fid, dom_id, patch_id
        character(:),   allocatable :: patch_name, domain_name, group_name

        fid = open_file_hdf(file_name)

        do igroup = 1,data%mesh%nbc_patch_groups()
            do ipatch = 1,data%mesh%bc_patch_group(igroup)%npatches()

                idom        = data%mesh%bc_patch_group(igroup)%patch(ipatch)%idomain_l()
                patch_name  = data%mesh%bc_patch_group(igroup)%patch(ipatch)%name
                group_name  = data%mesh%bc_patch_group(igroup)%name
                domain_name = data%mesh%domain(idom)%name


                dom_id = open_domain_hdf(fid,domain_name)

                ! Check if patch exists        
                exists = check_link_exists_hdf(dom_id,"Patches/"//"P_"//trim(adjustl(patch_name)))
                if (.not. exists) then
                    patch_id = create_patch_hdf(dom_id,trim(adjustl(patch_name)))
                else
                    patch_id = open_patch_hdf(dom_id,trim(adjustl(patch_name)))
                end if 


                ! Allocate array to assemble connectivities
                nfaces = data%mesh%bc_patch_group(igroup)%patch(ipatch)%connectivity%nfaces()
                npts   = size(data%mesh%bc_patch_group(igroup)%patch(ipatch)%connectivity%data(1)%data)
                if (allocated(faces)) deallocate(faces)
                allocate(faces(nfaces,npts), stat=ierr)
                if (ierr /= 0) call AllocationError

                ! Assemble patch connectivities
                do iface = 1,nfaces
                    faces(iface,:) = data%mesh%bc_patch_group(igroup)%patch(ipatch)%connectivity%data(iface)%data
                end do

                ! Set connectivies and group association
                call set_patch_hdf(patch_id,faces)
                call set_patch_group_hdf(patch_id,trim(group_name))

                call close_patch_hdf(patch_id)
                call close_domain_hdf(dom_id)

            end do !ipatch
        end do !igroup


        call close_file_hdf(fid)


    end subroutine write_patches_hdf
    !****************************************************************************************






    !>  Write boundary condition state groups to file.
    !!
    !!  Writes and all boundary condition state groups to the file.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   6/20/2017
    !!
    !---------------------------------------------------------------------------------------
    subroutine write_bc_state_groups_hdf(data,file_name)
        type(chidg_data_t), intent(in)  :: data
        character(*),       intent(in)  :: file_name

        integer(ik)                 :: igroup, istate, ierr
        integer(HID_T)              :: fid, bcsg_id
        character(:),   allocatable :: group_name, state_name
        logical                     :: exists

        fid = open_file_hdf(file_name)


        !
        ! Add boundary condition state groups to the file.
        !
        do igroup = 1,data%nbc_state_groups()
            group_name = data%bc_state_group(igroup)%get_name()

            !
            ! If the group already exists, completely remove so we don't end up with
            ! conflicting settings.
            !
            exists = check_link_exists_hdf(fid,"BCSG_"//group_name)
            if (exists) call remove_bc_state_group_hdf(fid,trim(group_name))

            !
            ! Add all states
            !
            call create_bc_state_group_hdf(fid,trim(group_name))
            bcsg_id = open_bc_state_group_hdf(fid,trim(group_name))

            do istate = 1,data%bc_state_group(igroup)%nbc_states()

                state_name = data%bc_state_group(igroup)%bc_state(istate)%state%name
                call add_bc_state_hdf(bcsg_id, data%bc_state_group(igroup)%bc_state(istate)%state)

            end do !istate


            call close_bc_state_group_hdf(bcsg_id)
        end do !igroup


        call close_file_hdf(fid)

    end subroutine write_bc_state_groups_hdf
    !***************************************************************************************








    !>  Read the equation set groups that are defined in the HDF file.
    !!
    !!  @author Nathan A. Wukie
    !!  @date   2/3/2016
    !!
    !!  @param[in]      filename    Character string of the file to be read from
    !!  @param[inout]   data        chidg_data_t instance where the equations will be added.
    !!
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_equations_hdf(data,filename)
        type(chidg_data_t), intent(inout)   :: data
        character(*),       intent(in)      :: filename

        integer(HID_T)                  :: fid
        integer                         :: ierr, ifield

        character(:),       allocatable :: user_msg
        logical                         :: file_exists, contains_solution

        type(svector_t) :: eqn_groups
        type(string_t)  :: eqn_string

        ! Open file
        fid = open_file_hdf(filename)

        ! Get equation names
        eqn_groups = get_eqn_group_names_hdf(fid)

        ! Close file
        call close_file_hdf(fid)

        ! Add equation groups to chidg_data
        do ifield = 1,eqn_groups%size()
            eqn_string = eqn_groups%at(ifield)
            call data%add_equation_set(eqn_string%get())
        end do

    end subroutine read_equations_hdf
    !****************************************************************************************










    !>  Write the equation set groups that are defined in chidg_data to the HDF file.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   5/30/2017
    !!
    !!  @param[in]      filename    Character string of the file to be read to.
    !!  @param[inout]   data        chidg_data_t we will write equation set groups from.
    !!
    !!
    !----------------------------------------------------------------------------------------
    subroutine write_equations_hdf(data,filename)
        type(chidg_data_t), intent(inout)   :: data
        character(*),       intent(in)      :: filename

        integer(HID_T)                  :: fid
        integer(ik)                     :: ierr, eqn_ID

        character(:),       allocatable :: user_msg, eqnset_name
        logical                         :: file_exists, contains_solution

        type(svector_t) :: eqn_groups
        type(string_t)  :: eqn_string

        ! Open file
        fid = open_file_hdf(filename)

        ! Add equation groups to chidg_data
        do eqn_ID = 1,data%nequation_sets()

            eqnset_name = data%get_equation_set_name(eqn_ID)
            call create_eqn_group_hdf(fid,eqnset_name)

        end do !eqn_ID

        ! Close file
        call close_file_hdf(fid)

    end subroutine write_equations_hdf
    !****************************************************************************************












    !>  This reads an HDF ChiDG grid file and returns an array of connectivities, one 
    !!  for each domain.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   6/9/2016
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_global_connectivity_hdf(filename, connectivities)
        character(*),                               intent(in)      :: filename
        type(domain_connectivity_t), allocatable,   intent(inout)   :: connectivities(:)

        integer(HID_T)   :: fid, domain_id

        integer(ik),            allocatable :: connectivity(:,:)
        character(len=1024),    allocatable :: domain_names(:)
        character(:),           allocatable :: user_msg, domain_name
        integer                             :: type, ierr, ndomains,    &
                                               idom, idomain, nelements, ielem, nnodes, mapping
        logical                             :: contains_grid


        fid = open_file_hdf(filename)

        ! Check contains grid
        contains_grid = get_contains_grid_hdf(fid)
        user_msg = "We didn't find a grid to read in the file that was specified. &
                    The file could be a bare ChiDG file or maybe was generated by &
                    an incompatible version of the ChiDG library."
        if (.not. contains_grid) call chidg_signal(FATAL,user_msg)


        !  Allocate number of domains
        ndomains = get_ndomains_hdf(fid)
        user_msg = "read_global_connectivity_hdf: No domains were found in the file."
        if (ndomains == 0) call chidg_signal(FATAL,user_msg)
        allocate(connectivities(ndomains), stat=ierr)
        if (ierr /= 0) call AllocationError


        ! Loop through groups and read domain connectivities
        domain_names = get_domain_names_hdf(fid)
        do idom = 1,size(domain_names)

                domain_name = domain_names(idom)
                domain_id = open_domain_hdf(fid,trim(domain_name))


                ! Get connectivity and total number of nodes in the domain
                connectivity = get_domain_connectivity_hdf(domain_id)
                nnodes       = get_domain_nnodes_hdf(domain_id)


                ! Initialize domain connectivity structure
                nelements = size(connectivity,1)
                call connectivities(idom)%init(domain_name,nelements, nnodes)


                do ielem = 1,nelements
                    mapping = connectivity(ielem,3)
                    call connectivities(idom)%data(ielem)%init(mapping)
                    connectivities(idom)%data(ielem)%data = connectivity(ielem,:)
                    call connectivities(idom)%data(ielem)%set_element_partition(NO_PROC)
                end do


                ! Close domain
                call close_domain_hdf(domain_id)

        end do  ! idom


        ! Close file
        call close_file_hdf(fid)

    end subroutine read_global_connectivity_hdf
    !****************************************************************************************








    !>  Read the weights of each domain.
    !!
    !!  The weights here are defined as relative weight of compute intensity.
    !!  So, for example, a domain solving the Euler equations might be weighted 1, 
    !!  whereas a domain solving the Navier Stokes equations might be weighted 5.
    !!  Additionally, the weight might be based on solution order. So, a P1 domain might
    !!  be weighted 1 and a P2 domain might be weighted 8. 
    !!
    !!  @author Nathan A. Wukie
    !!  @date   10/25/2016
    !!
    !!
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_weights_hdf(chidg_file,weights)
        character(*),               intent(in)      :: chidg_file
        real(rk),   allocatable,    intent(inout)   :: weights(:)



    end subroutine read_weights_hdf
    !*****************************************************************************************






    ! Mesh Motion



    !>  Read mesh motion from HDF5 file in ChiDG format and return data in bcdata_t
    !!  container. The calling procedure can then use the returned bcdata_t to initialize
    !!  boundary conditions.
    !!
    !!  @author Eric Wolf
    !!  @date   3/29/2017
    !!
    !!  @param[in]      filename    String of the HDF5 file to be read.
    !!  @param[inout]   bcdata(:)   Array of bcdata_t instances, one for each domain. 
    !!                              These will be returned with data about the boundary
    !!                              conditions that can be used for initialization.
    !!  @param[in]      partition   Partition information to only read boundary conditions 
    !!                              for the domains in the partition
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_mesh_motion_hdf(filename, pmm_domain_data, pmm_group_wrapper, partition)
        character(*),                       intent(in)                  :: filename
        type(mesh_motion_domain_data_t),    intent(inout), allocatable  :: pmm_domain_data(:)
        type(mesh_motion_group_wrapper_t),  intent(inout)               :: pmm_group_wrapper
        type(partition_t),                  intent(in)                  :: partition

        integer(HID_T)  :: fid
        integer         :: ierr, nconn

        fid = open_file_hdf(filename)

        !  Allocate for number of domains in the partition
        nconn = size(partition%connectivities)
        allocate(pmm_domain_data(nconn), stat=ierr)
        if (ierr /= 0) call AllocationError

        ! Read prescribed mesh motion
        call read_mm_domain_data_hdf(fid, pmm_domain_data, partition)
        call read_mm_groups_hdf(fid,pmm_group_wrapper,partition)

        call close_file_hdf(fid)

    end subroutine read_mesh_motion_hdf
    !****************************************************************************************




    !>  Read the boundary condition patch connectivity data from file and store in
    !!  bc_patch_data.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   8/31/2016
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_mm_domain_data_hdf(fid,pmm_domain_data, partition)
        integer(HID_T),                     intent(in)      :: fid
        type(mesh_motion_domain_data_t),    intent(inout)   :: pmm_domain_data(:)
        type(partition_t),                  intent(in)      :: partition

        integer(HID_T)                  :: domain_id
        integer(ik)                     :: iconn, nconn, iface, ierr
        character(len=:), allocatable   :: pmm_group
        integer                         :: ibc_face, nbcfaces
        character(1024)                 :: domain

        integer(HID_T)                  :: patch_id

        ! Loop through connectivities and read boundary conditions
        nconn = size(partition%connectivities)
        do iconn = 1,nconn

            ! Get name of current domain
            domain = partition%connectivities(iconn)%get_domain_name()
            pmm_domain_data(iconn)%domain_name = domain

            ! Get the name of the PMM group for the current domain.
            ! This is stored as an attribute.
            call h5gopen_f(fid, "D_"//trim(domain), domain_id, ierr)
            if (ierr /= 0) call chidg_signal(FATAL,"read_mm_domain_data_hdf: error opening domain group")
            
            ! Read Boundary State Group
            pmm_group = get_mm_domain_group_hdf(domain_id)
            pmm_domain_data(iconn)%mm_group_name = trim(pmm_group)

            ! Close face boundary condition group
            call h5gclose_f(domain_id, ierr)
            if (ierr /= 0) call chidg_signal(FATAL,"read_mm_domain_data_hdf: h5gclose")

        end do  ! iconn

    end subroutine read_mm_domain_data_hdf
    !****************************************************************************************



    !>  Read boundary condition state groups from file and return.
    !!
    !!  Reads and returns all boundary condition state groups, regardless of if they
    !!  are used on the current partition or not.
    !!
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   8/31/2016
    !!
    !---------------------------------------------------------------------------------------
    subroutine read_mm_groups_hdf(fid, pmm_groups_wrapper, partition)
        integer(HID_T),                     intent(in)      :: fid
        type(mesh_motion_group_wrapper_t),  intent(inout)   :: pmm_groups_wrapper
        type(partition_t),                  intent(in)      :: partition

        type(svector_t)                     :: pmm_group_names, pmm_names
        type(string_t)                      :: group_name, pmm_name
        class(mesh_motion_t),  allocatable  :: pmm, pmm_temp

        integer(HID_T)  :: group_id
        integer(ik)     :: igroup, ngroups, istate, ierr


        ngroups        = get_nmm_groups_hdf(fid)
        pmm_group_names = get_mm_group_names_hdf(fid)


        ! Read each group of pmm's
        if (ngroups>0) then

            if (allocated(pmm_groups_wrapper%mm_groups)) deallocate(pmm_groups_wrapper%mm_groups)
            allocate(pmm_groups_wrapper%mm_groups(ngroups), stat=ierr)
            if (ierr /= 0) call AllocationError


            do igroup = 1,ngroups

                ! Open face boundary condition group
                group_name = pmm_group_names%at(igroup)
                !group_id = open_pmm_group_hdf(fid,group_name%get())
                group_id = open_mm_group_hdf(fid, trim(group_name%get()))
                !call h5gopen_f(fid, "MM_"//trim(group_name%get()), group_id, ierr)
                !if (ierr /= 0) call chidg_signal_one(FATAL,"read_mm_groups_hdf: error opening bc_state group.",trim(pmm_name%get()))


                if (allocated(pmm)) deallocate(pmm)
                if (allocated(pmm_temp)) deallocate(pmm_temp)
                
                
                call get_mm_hdf(fid,group_id, group_name%get(), pmm_temp)
                allocate(pmm, source = pmm_temp)

                ! Save to pmm_group_t
                pmm_groups_wrapper%ngroups = pmm_groups_wrapper%ngroups+1
                pmm_groups_wrapper%mm_groups(igroup)%name = trim(group_name%get())
                allocate(pmm_groups_wrapper%mm_groups(igroup)%mm, source = pmm)
                !pmm_groups_wrapper%pmm_groups(igroup)%pmm = pmm



                ! Close boundary condition state group
                call h5gclose_f(group_id, ierr)
                if (ierr /= 0) call chidg_signal(FATAL,"read_mm_groups_hdf: h5gclose")


            end do !igroup
        end if



    end subroutine read_mm_groups_hdf
    !****************************************************************************************






    !>  This reads an HDF ChiDG grid file and returns an array of connectivities, one 
    !!  for each domain.
    !!
    !!  @author Nathan A. Wukie (AFRL)
    !!  @date   6/9/2016
    !!
    !----------------------------------------------------------------------------------------
    subroutine read_global_nodes_hdf(filename, global_nodes)
        character(*),               intent(in)      :: filename
        real(rk),   allocatable,    intent(inout)   :: global_nodes(:,:)

        integer(HID_T)   :: fid, domain_id

        integer(ik),            allocatable :: connectivity(:,:)
        character(len=1024),    allocatable :: domain_names(:)
        character(:),           allocatable :: user_msg, domain_name
        integer                             :: type, ierr, ndomains,    &
                                               idom, idomain, nelements, ielem, nnodes, mapping, nnodes_g
        logical                             :: contains_grid


        fid = open_file_hdf(filename)


        ! Check contains grid
        contains_grid = get_contains_grid_hdf(fid)
        user_msg = "We didn't find a grid to read in the file that was specified. &
                    The file could be a bare ChiDG file or maybe was generated by &
                    an incompatible version of the ChiDG library."
        if (.not. contains_grid) call chidg_signal(FATAL,user_msg)


        ! Allocate number of domains
        ndomains = get_ndomains_hdf(fid)
        user_msg = "read_global_connectivity_hdf: No domains were found in the file."
        if (ndomains == 0) call chidg_signal(FATAL,user_msg)


        ! Loop through groups and read domain connectivities
        domain_names = get_domain_names_hdf(fid)
        nnodes_g = 0
        do idom = 1,size(domain_names)
            domain_name = domain_names(idom)
            domain_id = open_domain_hdf(fid,trim(domain_name))

            ! Get connectivity and total number of nodes in the domain
            nnodes       = get_domain_nnodes_hdf(domain_id)
            nnodes_g = nnodes_g+nnodes

            call close_domain_hdf(domain_id)
        end do

        allocate(global_nodes(nnodes_g, 3))

        nnodes_g = 0
        do idom = 1,size(domain_names)

                domain_name = domain_names(idom)
                domain_id = open_domain_hdf(fid,trim(domain_name))

                ! Get connectivity and total number of nodes in the domain
                !connectivity = get_domain_connectivity_hdf(domain_id)
                nnodes       = get_domain_nnodes_hdf(domain_id)
 
                global_nodes(nnodes_g+1:nnodes_g+nnodes,:) = get_domain_coordinates_hdf(domain_id)
                nnodes_g = nnodes_g + nnodes
!                !
!                ! Initialize domain connectivity structure
!                !
!                nelements = size(connectivity,1)
!                call connectivities(idom)%init(domain_name,nelements, nnodes)
!
!
!                do ielem = 1,nelements
!                    mapping = connectivity(ielem,3)
!                    call connectivities(idom)%data(ielem)%init(mapping)
!                    connectivities(idom)%data(ielem)%data = connectivity(ielem,:)
!                    call connectivities(idom)%data(ielem)%set_element_partition(NO_PROC)
!                end do


                ! Close domain
                call close_domain_hdf(domain_id)

        end do  ! idom


        ! Close file
        call close_file_hdf(fid)

    end subroutine read_global_nodes_hdf
    !****************************************************************************************






end module mod_hdfio

module fcl_yforce_coeff
#include <messenger.h>
    use mod_kinds,                  only: ik, rk
    use type_evaluator,             only: evaluator_t
    use type_chidg_worker,          only: chidg_worker_t
    use mod_fluid,                  only: Rgas,cp, gam
    use mod_constants,              only: HALF, ONE
    use type_functional_cache,      only: functional_cache_t
    use type_chidg_vector,          only: chidg_vector_t
    use mod_functional_operators
    use DNAD_D
    implicit none



    !>  This functional computes the Y-force Coefficient generated by a given surface, using the
    !!  following equation:
    !!
    !!      Cy = Fy/(rho_inf*v_inf^2*0.5) 
    !!
    !!  Two geometries need to be defined:
    !!      - reference -> used to compute the Y-force Fy (ex wing, viscous_plate)
    !!      - auxiliary -> used to compute the area average properties in the free
    !!                     stream (rho_inf & v_inf)
    !!
    !!  NOTE: the Fx coefficient should be divided by the reference area. Since the reference
    !!        area is arbitrary, it is left out from the calculation. 
    !!
    !!  
    !!  @author Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !!  Restructured functional computation
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  TODO: to be tested
    !!
    !------------------------------------------------------------------------------------------
    type,  extends(evaluator_t), public   :: yforce_coeff_t

        ! Quantities needed for the computation
        ! Used to check completeness of information provided
        integer(ik)     :: min_ref_geom = 1
        integer(ik)     :: min_aux_geom = 1
        integer(ik)     :: max_ref_geom = 100
        integer(ik)     :: max_aux_geom = 100

    contains

        procedure, public   :: init
        procedure, public   :: check
        procedure, public   :: compute_functional
        procedure, public   :: finalize_functional
        procedure, public   :: compute_auxiliary
        procedure, public   :: finalize_auxiliary
        procedure, public   :: store_value
        procedure, public   :: store_deriv

    end type yforce_coeff_t
    !******************************************************************************************

    


contains


    !>  Initialize the functional
    !!
    !!
    !!  @author Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !!
    !------------------------------------------------------------------------------------------
    subroutine init(self)
        class(yforce_coeff_t), intent(inout)   :: self

        call self%set_name("Y-force Coefficient")
        call self%set_eval_type("Functional")
        call self%set_int_type("FACE INTEGRAL")

    end subroutine init
    !******************************************************************************************





    !>  This procedure checks that all the information have been provided by the user to fully 
    !!  compute the functional
    !!
    !!  @author Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !------------------------------------------------------------------------------------------
    subroutine check(self)
        class(yforce_coeff_t), intent(inout)   :: self

        integer(ik)                     :: aux_geoms, ref_geoms
        character(len=:), allocatable   :: usr_msg_r, usr_msg_a
        logical                         :: ref_geoms_exceed, aux_geoms_exceed

        ! Check that the functional has all the information needed
        ref_geoms = self%n_ref_geom()
        aux_geoms = self%n_aux_geom()

        ref_geoms_exceed = (ref_geoms < self%min_ref_geom .or. ref_geoms > self%max_ref_geom)
        aux_geoms_exceed = (aux_geoms < self%min_aux_geom .or. aux_geoms > self%max_aux_geom)

        usr_msg_r = "fcl_yforce_coeff: wrong number of reference geometries. The minimum number of reference geometries is 1."
        usr_msg_a = "fcl_yforce_coeff: wrong number of auxiliary geometries. The minimum number of auxiliary geometries is 1."

        if (ref_geoms_exceed) call chidg_signal(FATAL, usr_msg_r)
        if (aux_geoms_exceed) call chidg_signal(FATAL, usr_msg_a)

    end subroutine check 
    !******************************************************************************************






    !>  This subroutine is meant to compute the auxiliary integral.
    !!  Rho_inf and v_inf need to be computed on the auxiliary geometry
    !!  
    !!
    !!  @author Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !!  Restructured functional computation
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  param[inout]       worker
    !!  param[inout]       cache        ! Storage for functional integrals
    !!
    !------------------------------------------------------------------------------------------
    subroutine compute_auxiliary(self,worker,cache)
        class(yforce_coeff_t),      intent(inout)   :: self
        type(chidg_worker_t),       intent(inout)   :: worker
        type(functional_cache_t),   intent(inout)   :: cache

        type(AD_D), allocatable, dimension(:) :: density, mom_1, mom_2, mom_3,  &
                                                 u_1, u_2, u_3, umag, r,        &
                                                 dynamic_pressure
        real(rk),   allocatable, dimension(:) :: weights
        type(AD_D)                            :: cell_count, Ke_average,        &
                                                 ave_dynamic_pressure
        
        
        ! Get primary fields
        density     = worker%get_field('Density'   ,'value','face interior')
        mom_1       = worker%get_field('Momentum-1','value','face interior')
        mom_2       = worker%get_field('Momentum-2','value','face interior')
        mom_3       = worker%get_field('Momentum-3','value','face interior')


        ! Account for cylindrical coordinates
        r = worker%coordinate('1','face interior')
        if (worker%coordinate_system() == 'Cylindrical') then
            mom_2 = mom_2/r
        else if (worker%coordinate_system() == 'Cartesian') then

        else
            call chidg_signal(FATAL,'bad coordinate system')
        end if

         
        ! Compute velocities
        u_1 = mom_1/density
        u_2 = mom_2/density
        u_3 = mom_3/density
        umag = sqrt(u_1*u_1 + u_2*u_2 + u_3*u_3)
        
         
        ! Compute Kinetic energy at freestream
        dynamic_pressure = HALF*density*umag**2

         
        ! Compute area and integrate Ke over face area
        ave_dynamic_pressure = average(worker,dynamic_pressure)
        cell_count           = ave_dynamic_pressure
        cell_count           = ONE
        

        ! Store in cache 
        call cache%set_value(worker%mesh,ave_dynamic_pressure,'dynamic pressure','auxiliary',worker%function_info) 
        call cache%set_value(worker%mesh,cell_count,          'cell count',      'auxiliary',worker%function_info) 
    
    end subroutine compute_auxiliary
    !******************************************************************************************
    
    
    
    
    
    
    !>  This surboutine finalize the auxiliary integral.  
    !!  We computed the averaged dynamic pressure and e areas. Now, we sum all the Ke and area
    !!
    !!  The quantities stored are:
    !!      - Ke_inf = sum_el(Ke_e)/cell_count
    !!
    !!  @auhtor Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !!
    !!  Restructured functional computation
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  param[inout]       cache     cache contains the overall iintegrals value at this point,
    !!                               since the parallel communication already happened 
    !!
    !---------------------------------------------------------------------------------------------
    subroutine finalize_auxiliary(self,worker,cache)
        class(yforce_coeff_t),      intent(inout)   :: self
        type(chidg_worker_t),       intent(in)      :: worker
        type(functional_cache_t),   intent(inout)   :: cache
        
        type(AD_D)        :: dynamic_pressure, cell_count
        
        dynamic_pressure = cache%get_value(worker%mesh,'dynamic pressure','auxiliary')
        cell_count       = cache%get_value(worker%mesh,'cell count',      'auxiliary')

        call cache%set_value(worker%mesh,dynamic_pressure/cell_count,'dynamic pressure','auxiliary')

    end subroutine finalize_auxiliary
    !*********************************************************************************************






    !>  Computing the yforce coefficient 
    !!  Taken from mod_chidg_airfoil.f90
    !!
    !!  @author Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !!  Restructured functional computation
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  param[inout]       cache     cache contains the overall iintegrals value at this point,
    !!                               since the parallel communication already happened 
    !------------------------------------------------------------------------------------------
    subroutine compute_functional(self,worker,cache)
        class(yforce_coeff_t),      intent(inout)   :: self
        type(chidg_worker_t),       intent(inout)   :: worker
        type(functional_cache_t),   intent(inout)   :: cache


        integer(ik)             :: idomain_g, ielement_g, iface, ierr
        
        type(AD_D), allocatable, dimension(:) :: pressure, tau_11, tau_22, tau_33,  &
                                                 tau_12, tau_13, tau_23, tau_21,    &
                                                 tau_31, tau_32, yforce_gq, stress_x, &
                                                 stress_y, stress_z,                &
                                                 norm_1, norm_2, norm_3,            &
                                                 unorm_1, unorm_2, unorm_3,         &
                                                 areas 

        type(AD_D)                            :: yforce

        
        ! Get pressure
        pressure = worker%get_field('Pressure', 'value', 'face interior')


        ! Get shear stress tensor
        tau_11 = worker%get_field('Shear-11', 'value', 'face interior')
        tau_22 = worker%get_field('Shear-22', 'value', 'face interior')
        tau_33 = worker%get_field('Shear-33', 'value', 'face interior')
        tau_12 = worker%get_field('Shear-12', 'value', 'face interior')
        tau_13 = worker%get_field('Shear-13', 'value', 'face interior')
        tau_23 = worker%get_field('Shear-23', 'value', 'face interior')

        ! From symmetry
        tau_21 = tau_12
        tau_31 = tau_13
        tau_32 = tau_23

        
        ! Add pressure component
        tau_11 = tau_11 - pressure
        tau_22 = tau_22 - pressure
        tau_33 = tau_33 - pressure


        ! Get normal vectors and reverse, because we want outward-facing vector from
        ! the geometry.
        norm_1  = -worker%normal(1)
        norm_2  = -worker%normal(2)
        norm_3  = -worker%normal(3)

        unorm_1 = -worker%unit_normal(1)
        unorm_2 = -worker%unit_normal(2)
        unorm_3 = -worker%unit_normal(3)
        

        ! Compute \vector{n} dot \tensor{tau}
        !   : These should produce the same result since the tensor is 
        !   : symmetric. Not sure which is more correct.
        !
        !stress_x = unorm_1*tau_11 + unorm_2*tau_21 + unorm_3*tau_31
        !stress_y = unorm_1*tau_12 + unorm_2*tau_22 + unorm_3*tau_32
        !stress_z = unorm_1*tau_13 + unorm_2*tau_23 + unorm_3*tau_33
        stress_x = tau_11*unorm_1 + tau_12*unorm_2 + tau_13*unorm_3
        stress_y = tau_21*unorm_1 + tau_22*unorm_2 + tau_23*unorm_3
        stress_z = tau_31*unorm_1 + tau_32*unorm_2 + tau_33*unorm_3


        ! Compute yforce Force at quadrature nodes
        yforce_gq = stress_y
        
        
        ! Compute face integral over the element face
        yforce = integrate_surface(worker,yforce_gq)

        
        ! Store in cache 
        call cache%set_value(worker%mesh,yforce,'yforce','reference',worker%function_info)

    end subroutine compute_functional
    !******************************************************************************************




    
    
    !>  Finalize subroutine carries out the final computation before storing the functional
    !!  It comes after the parallel communcation and input argument cache has 
    !!  the overall integral over the reference geometry.
    !!
    !!  For yforce coefficient computation, the overall yforce force needs to be divided 
    !!  by HALF*rho*v^2 at freestream
    !!
    !!  @auhtor Matteo Ugolotti
    !!  @date   07/12/2018
    !!
    !!  Restructured functional computation
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  param[inout]       cache     cache contains the overall iintegrals value at this point,
    !!                               since the parallel communication already happened 
    !---------------------------------------------------------------------------------------------
    subroutine finalize_functional(self,worker,cache) 
        class(yforce_coeff_t),      intent(inout)   :: self
        type(chidg_worker_t),       intent(in)      :: worker
        type(functional_cache_t),   intent(inout)   :: cache

        type(AD_D)        :: yforce, dynamic_pressure
        
        yforce           = cache%get_value(worker%mesh,'yforce',          'reference')
        dynamic_pressure = cache%get_value(worker%mesh,'dynamic pressure','auxiliary')

        call cache%set_value(worker%mesh,yforce/dynamic_pressure,'Fy coefficient','reference')

    end subroutine finalize_functional
    !*********************************************************************************************



    
    
    
    !>  Store the real value of the actual final functional integral 
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  param[inout]       cache     Storage for integrals, this contains the overall 
    !!                               functional (ie after parallel communication).     
    !!
    !---------------------------------------------------------------------------------------------
    function store_value(self,cache) result(res) 
        class(yforce_coeff_t),      intent(inout)   :: self
        type(functional_cache_t),   intent(inout)   :: cache

        real(rk)          :: res

        res = cache%ref_cache%get_real('Fy coefficient')

    end function store_value
    !*********************************************************************************************



    
    
    !>  Store the derivatives of the actual final functional integral 
    !!
    !!  @author Matteo Ugolotti
    !!  @date   3/7/2019
    !!
    !!  param[inout]       cache     Storage for integrals, this contains the overall 
    !!                               functional (ie after parallel communication).     
    !!
    !---------------------------------------------------------------------------------------------
    function store_deriv(self,cache) result(res) 
        class(yforce_coeff_t),      intent(inout)   :: self
        type(functional_cache_t),   intent(inout)   :: cache

        type(chidg_vector_t)       :: res
        
        res = cache%ref_cache%get_deriv('Fy coefficient')

    end function store_deriv
    !*********************************************************************************************
    
end module fcl_yforce_coeff

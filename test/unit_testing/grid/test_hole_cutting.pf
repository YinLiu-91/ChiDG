@Test
subroutine test_hole_cutting()
    use pfunit_mod
    use type_chidg,             only: chidg_t
    use mod_constants,          only: ZERO, ONE, TWO, PI
    use mod_kinds,              only: rk, ik
    use mod_chidg_mpi,          only: ChiDG_COMM
    use mod_tioga_interfaces,   only: tioga_init_f90, tioga_registergrid_data_mb, tioga_preprocess_grids, tioga_performconnectivity
    !use mod_tioga_interfaces,   only: tioga_init_f90, tioga_preprocess_grids, tioga_performconnectivity
    use mod_gridspace,          only: linspace
    use iso_c_binding,          only: c_int, c_double, c_ptr, c_null_ptr, c_loc
    implicit none

    integer(c_int), target :: bid1, btag1, nnodes1, nwall_nodes1, noverset_nodes1, nelement_types1, nvertices_per_element1, nelements1
    integer(c_int), target :: bid2, btag2, nnodes2, nwall_nodes2, noverset_nodes2, nelement_types2, nvertices_per_element2, nelements2

    real(c_double), allocatable, dimension(:),      target  :: xyz1, xyz2, radii, thetas, zs, xs, ys
    !integer(c_int), allocatable, dimension(:,:),    target  :: connectivity1, connectivity2
    integer(c_int), allocatable, dimension(:),      target  :: connectivity1, connectivity2
    integer(c_int), allocatable, dimension(:),      target  :: iblank1, iblank2, wall_nodes1, wall_nodes2, overset_nodes1, overset_nodes2

    integer(c_int)  :: nnodes_xi, nnodes_eta, nnodes_zeta, inode, inode_xi, inode_eta, inode_zeta, iwall_node, ioverset_node, &
                       nelem_xi, nelem_eta, nelem_zeta, ielem, ielem_xi, ielem_eta, ielem_zeta, node_start
    type(c_ptr) :: connectivity1_p, connectivity2_p, nvertices_per_element1_p, nelements1_p, xyz1_p, iblank1_p, wall_nodes1_p, overset_nodes1_p

    real(c_double) :: r_in, r_out, r, theta, z, x, y, x_max, x_min, y_max, y_min, z_max, z_min
    
    type(chidg_t)   :: chidg

    connectivity1_p = c_null_ptr
    connectivity2_p = c_null_ptr

    nvertices_per_element1_p = c_null_ptr
    nelements1_p = c_null_ptr

    call chidg%start_up('mpi')
    call chidg%start_up('core')

    ! Initialize tioga library
    call tioga_init_f90(ChiDG_COMM)



    ! Assemble multiblock grid

    ! Block 1
    bid1  = 1
    btag1 = 1
    nnodes_xi = 10
    nnodes_eta = 10
    nnodes_zeta = 2
    nelem_xi   = nnodes_xi-1
    nelem_eta  = nnodes_eta-1
    nelem_zeta = nnodes_zeta-1
    nnodes1 = nnodes_xi * nnodes_eta * nnodes_zeta
    nwall_nodes1 = nnodes_eta*nnodes_zeta
    !noverset_nodes1 = nnodes_eta*nnodes_zeta
    noverset_nodes1 = 0
    nelement_types1 = 1
    nvertices_per_element1 = 8
    nelements1 = nelem_xi * nelem_eta * nelem_zeta

    !allocate(xyz1(3*nnodes1), iblank1(nnodes1), wall_nodes1(nwall_nodes1), overset_nodes1(noverset_nodes1), connectivity1(nvertices_per_element1,nelements1))
    allocate(xyz1(3*nnodes1), iblank1(nnodes1), wall_nodes1(nwall_nodes1), overset_nodes1(noverset_nodes1), connectivity1(nvertices_per_element1*nelements1*100))



    r_in   = 0.5
    r_out  = 1.5
    radii  = real(linspace(real(r_in,rk),real(r_out,rk),int(nnodes_xi,  ik)), c_double)
    thetas = real(linspace(ZERO,         TWO*PI,        int(nnodes_eta, ik)), c_double)
    zs     = real(linspace(ZERO,         ONE,           int(nnodes_zeta,ik)), c_double)


    ! Assemble nodes
    inode         = 1
    iwall_node    = 1
    ioverset_node = 1
    do inode_zeta = 1,nnodes_zeta
        do inode_eta = 1,nnodes_eta
            do inode_xi = 1,nnodes_xi
                r     = radii(inode_xi)
                theta = thetas(inode_eta)
                z     = zs(inode_zeta)
                xyz1(3*inode-2) = r*cos(theta)
                xyz1(3*inode-1) = r*sin(theta)
                xyz1(3*inode-0) = z

                ! Store wall, overset node lists
                if (inode_xi == 1) then
                    wall_nodes1(iwall_node) = inode
                    iwall_node = iwall_node + 1
                end if
!                if (inode_xi == nnodes_xi) then
!                    overset_nodes1(ioverset_node) = inode
!                    ioverset_node = ioverset_node + 1
!                end if

                ! Next
                inode = inode + 1
            end do
        end do
    end do

    ! Assemble element connectivities
    do ielem_zeta = 1,(nnodes_zeta-1)
        do ielem_eta = 1,(nnodes_eta-1)
            do ielem_xi = 1,(nnodes_xi-1)
                ielem = (nelem_xi*nelem_eta)*(ielem_zeta-1) + (nelem_xi)*(ielem_eta-1) + ielem_xi
                node_start = (nnodes_xi*nnodes_eta)*(ielem_zeta-1) + (nnodes_xi)*(ielem_eta-1) + ielem_xi
                connectivity1(nvertices_per_element1*(ielem-1) + 1) = node_start
                connectivity1(nvertices_per_element1*(ielem-1) + 2) = node_start + 1
                connectivity1(nvertices_per_element1*(ielem-1) + 3) = node_start + nnodes_xi
                connectivity1(nvertices_per_element1*(ielem-1) + 4) = node_start + nnodes_xi + 1
                connectivity1(nvertices_per_element1*(ielem-1) + 5) = node_start + (nnodes_xi*nnodes_eta)
                connectivity1(nvertices_per_element1*(ielem-1) + 6) = node_start + (nnodes_xi*nnodes_eta) + 1
                connectivity1(nvertices_per_element1*(ielem-1) + 7) = node_start + (nnodes_xi*nnodes_eta) + nnodes_xi
                connectivity1(nvertices_per_element1*(ielem-1) + 8) = node_start + (nnodes_xi*nnodes_eta) + nnodes_xi + 1
!                connectivity1(1,ielem) = node_start
!                connectivity1(2,ielem) = node_start + 1
!                connectivity1(3,ielem) = node_start + nnodes_xi
!                connectivity1(4,ielem) = node_start + nnodes_xi + 1
!                connectivity1(5,ielem) = node_start + (nnodes_xi*nnodes_eta)
!                connectivity1(6,ielem) = node_start + (nnodes_xi*nnodes_eta) + 1
!                connectivity1(7,ielem) = node_start + (nnodes_xi*nnodes_eta) + nnodes_xi
!                connectivity1(8,ielem) = node_start + (nnodes_xi*nnodes_eta) + nnodes_xi + 1
            end do
        end do
    end do




!    ! Block 2
!    bid2  = 2
!    btag2 = 2
!    nnodes_xi = 10
!    nnodes_eta = 10
!    nnodes_zeta = 2
!    nnodes2 = nnodes_xi * nnodes_eta * nnodes_zeta
!    nwall_nodes2    = 0
!    noverset_nodes2 = 0
!    nelement_types2 = 1
!    nvertices_per_element2 = 8
!    nelements2 = (nnodes_xi-1) * (nnodes_eta-1) * (nnodes_zeta-1)
!
!    allocate(xyz2(3*nnodes2), iblank2(nnodes2), wall_nodes2(nwall_nodes2), overset_nodes2(noverset_nodes2))
!
!
!    x_min  = -2._rk
!    x_max  =  2._rk
!    y_min  = -2._rk
!    y_max  =  2._rk
!    z_min  =  0._rk
!    z_max  =  1._rk
!
!    xs = real(linspace(real(x_min,rk),real(x_max,rk),int(nnodes_xi,  ik)), c_double)
!    ys = real(linspace(real(y_min,rk),real(y_max,rk),int(nnodes_eta, ik)), c_double)
!    zs = real(linspace(real(z_min,rk),real(z_max,rk),int(nnodes_zeta,ik)), c_double)
!
!
!    inode = 1
!    iwall_node = 1
!    ioverset_node = 1
!    do inode_zeta = 1,nnodes_zeta
!        do inode_eta = 1,nnodes_eta
!            do inode_xi = 1,nnodes_xi
!                x = xs(inode_xi)
!                y = ys(inode_eta)
!                z = zs(inode_zeta)
!                xyz2(3*inode-2) = xs(inode_xi)
!                xyz2(3*inode-1) = ys(inode_eta)
!                xyz2(3*inode-0) = zs(inode_zeta)
!                inode = inode + 1
!            end do
!        end do
!    end do





    connectivity1_p = c_loc(connectivity1(1))
    xyz1_p = c_loc(xyz1(1))
    iblank1_p = c_loc(iblank1(1))
    wall_nodes1_p = c_loc(wall_nodes1(1))
    overset_nodes1_p = c_loc(overset_nodes1(1))
    nvertices_per_element1_p = c_loc(nvertices_per_element1)
    nelements1_p = c_loc(nelements1)


    ! Register blocks
    call tioga_registergrid_data_mb(bid1, btag1, nnodes1, xyz1_p, iblank1_p, nwall_nodes1, noverset_nodes1, wall_nodes1_p, overset_nodes1_p, nelement_types1, nvertices_per_element1, nelements1, connectivity1_p)
    !call tioga_registergrid_data_mb(bid1, btag1, nnodes1, xyz1_p, iblank1_p, nwall_nodes1, noverset_nodes1, wall_nodes1_p, overset_nodes1_p, nelement_types1, nvertices_per_element1, nelements1, connectivity1_p)
!    call tioga_registergrid_data_mb(bid2, btag2, nnodes2, xyz2, iblank2, nwall_nodes2, noverset_nodes2, wall_nodes2, overset_nodes2, nelement_types2, nvertices_per_element2, nelements2, connectivity2)


!    subroutine tioga_registergrid_data_mb(bid, btag, nnodes, xyz, iblank, nwall_nodes, noverset_nodes, wall_nodes, overset_nodes, nelement_types, nvertices_per_element, nelements, connectivity) bind(C,name="tioga_registergrid_data_mb_")
!        use iso_c_binding,  only: c_int, c_double
!        implicit none
!        integer(c_int), intent(in)  :: bid
!        integer(c_int), intent(in)  :: btag
!        integer(c_int), intent(in)  :: nnodes
!        real(c_double), intent(in)  :: xyz(:)       ! [3*nnodes]
!        integer(c_int), intent(in)  :: iblank(:)    ! [nnodes?]
!        integer(c_int), intent(in)  :: nwall_nodes
!        integer(c_int), intent(in)  :: noverset_nodes
!        integer(c_int), intent(in)  :: wall_nodes(:)
!        integer(c_int), intent(in)  :: overset_nodes(:)
!        integer(c_int), intent(in)  :: nelement_types
!        integer(c_int), intent(in)  :: nvertices_per_element
!        integer(c_int), intent(in)  :: nelements
!        integer(c_int), intent(in)  :: connectivity(:,:)    ! [conn_size, nelements]
!    end subroutine




    ! Run tioga
    call tioga_preprocess_grids()
!    call tioga_performconnectivity()


    ! Get iblank data

    call assertTrue(.true.)

    
end subroutine test_hole_cutting
